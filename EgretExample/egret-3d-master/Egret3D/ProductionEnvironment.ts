module egret3d {
export var glsldata = {
	AOMap_fragment:"﻿uniform sampler2D aoMapTex ;void main(void){    diffuse.xyz * (texture2D( aoMapTex , varying_uv0 ).xyz+ vec3(0.5,0.5,0.5)) ;   }",
	BrightPassFilter:"﻿varying vec2 uv ;uniform sampler2D texture2D_1 ;void main(void){                vec4 color = texture2D( texture2D_1 , uv ) ;    float intensity = 0.2990 * color.x + 0.5870 * color.y + 0.1140* color.z ;        color.xyz = color.xyz - vec3(intensity,intensity,intensity) ;    gl_FragColor = color ;     }",
	Color_fragment:"﻿mat3 TBN ;struct MaterialSource{    vec3 diffuse;    vec3 ambient;    vec3 specular;    float alpha;    float cutAlpha;    float shininess;	float diffusePower;	float specularPower;	float ambientPower;	float normalPower;};varying vec4 varying_pos        ;varying highp vec2 varying_uv0  ;varying vec2 varying_uv1        ;varying vec3 varying_eyeNormal  ;varying vec4 varying_color		;varying vec3 varying_eyedir		;varying vec3 varying_tangent	;uniform float uniform_materialSource[16];vec4 test  ;vec4 diffuse  ;vec3 light    ;vec4 specular ;vec3 normal  ;vec3 eyedir  ;vec4 ttt  ;void main() {	test = vec4(1.0,1.0,1.0,1.0);	ttt = vec4(1.0,1.0,1.0,0.0);	diffuse = vec4(1.0,1.0,1.0,1.0);	light   = vec3(0.0,0.0,0.0);	normal = varying_eyeNormal ;	MaterialSource materialSource = MaterialSource( 		vec3(uniform_materialSource[0],uniform_materialSource[1],uniform_materialSource[2]) , 		vec3(uniform_materialSource[3],uniform_materialSource[4],uniform_materialSource[5]) , 		vec3(uniform_materialSource[6],uniform_materialSource[7],uniform_materialSource[8]) , 		uniform_materialSource[9] , 		uniform_materialSource[10] ,		uniform_materialSource[11] , 		uniform_materialSource[12] , 		uniform_materialSource[13] , 		uniform_materialSource[14] ,		uniform_materialSource[15] 		) ;	specular = vec4(materialSource.specular,0.0);	TBN[0] = -varying_tangent ;	TBN[2] = normalize( normal.xyz ) ;    TBN[1] = normalize( cross(TBN[0],TBN[2]) ); 	eyedir = varying_eyedir.xyz - varying_pos.xyz ; }",
	Composition:"﻿varying vec2 uv ;uniform sampler2D texture2D_1 ;uniform sampler2D texture2D_2 ;void main(void){	vec4 color = texture2D(texture2D_1, uv ) ;	color = texture2D(texture2D_2, uv ) + color ;    gl_FragColor = vec4(color.xyz, 1.0 );}",
	EnvironmentMapping_fragment:"﻿uniform samplerCube environmentMapTex ;uniform float reflectValue;void main(){  	vec3 r = reflect(-normalize(eyedir),  normal  );	vec4 reflectiveColor = textureCube(environmentMapTex,r.xyz);	diffuse.xyz = mix( diffuse.xyz,reflectiveColor.xyz, reflectValue );  }         ",
	GaussianBlurHorizontal:"﻿varying vec2 uv ;uniform sampler2D texture2D_1 ;uniform float uniform_sceneWidth ; const int blurSize = 30 ;const float bias = 0.1 ;void main(void){	float weightOffset = bias ;	float blurOffset = 1.0/uniform_sceneWidth ;    vec3 tc = vec3(0.0, 0.0, 0.0);	vec2 texCoord = uv ;	tc = texture2D(texture2D_1, texCoord).xyz * weightOffset ;    for (int i=0; i<blurSize; i++)     {	   weightOffset = bias - bias * float(i)/float(blurSize) ;       tc += texture2D(texture2D_1, uv.xy + vec2( 0.0, float(i) * blurOffset ) ).xyz * weightOffset ;       tc += texture2D(texture2D_1, uv.xy - vec2( 0.0, float(i) * blurOffset ) ).xyz * weightOffset ;    }    gl_FragColor = vec4(tc, 1.0 );}",
	GaussianBlurVertical:"﻿varying vec2 uv ;uniform sampler2D texture2D_1 ;uniform float uniform_sceneHeight ; const int blurSize = 30 ;const float bias = 0.1 ;void main(void){	float weightOffset = bias ;	float blurOffset = 1.0 / uniform_sceneHeight ;    vec3 tc = vec3(0.0, 0.0, 0.0);	vec2 texCoord = uv ;	tc = texture2D(texture2D_1, texCoord).xyz * weightOffset ;    for (int i=0; i<blurSize; i++)     {	   weightOffset = bias - bias * float(i)/float(blurSize) ;       tc += texture2D(texture2D_1, uv.xy + vec2( float(i) * blurOffset , 0.0 ) ).xyz * weightOffset ;       tc += texture2D(texture2D_1, uv.xy - vec2( float(i) * blurOffset , 0.0 ) ).xyz * weightOffset ;    }    gl_FragColor = vec4(tc, 1.0 );}",
	LightDiffuse_fragment:"struct MaterialSource{    vec4 ambient;    vec4 diffuse;    vec4 specular;    vec3 emission;    float shininess;};struct LightSource{    int lightType;    vec3 position;    float spotExponent;    vec3 spotDirection;    float spotCutoff;     vec3 halfVector;    float spotCosCutoff;     vec3 ambient;    float constantAttenuation;    vec3 diffuse;    float linearAttenuation;    vec3 specular;    float quadraticAttenuation;};const int maxLight = 1 ;uniform float uniform_LightSource[25];void main() {		lightColor = vec4( 0.0,0.0,0.0,1.0);        vec3 lightDir ,halfV;        vec4 diffuse ;        float NdotL , specularfract ;		        MaterialSource frontMaterial = MaterialSource( uniform_materialSource[0] , uniform_materialSource[1] , uniform_materialSource[2] , uniform_materialSource[3].xyz , uniform_materialSource[3].w  ) ;        for(int i = 0 ; i < maxLight ; i++){                                                                                                                                                                                                                                                                                                            					LightSource light;					light.lightType = int(uniform_LightSource[i*25]);					light.position = vec3(uniform_LightSource[i*25+1],uniform_LightSource[i*25+2],uniform_LightSource[i*25+3]);					light.spotExponent = uniform_LightSource[i*25+4];					light.spotDirection = vec3( uniform_LightSource[i*25+5],uniform_LightSource[i*25+6],uniform_LightSource[i*25+7]);					light.spotCutoff = uniform_LightSource[i*25+8];					light.halfVector = vec3( uniform_LightSource[i*25+9],uniform_LightSource[i*25+10],uniform_LightSource[i*25+11]);					light.spotCosCutoff = uniform_LightSource[i*25+12];					light.ambient = vec3( uniform_LightSource[i*25+13],uniform_LightSource[i*25+14],uniform_LightSource[i*25+15]);					light.constantAttenuation = uniform_LightSource[i*25+16];					light.diffuse = vec3( uniform_LightSource[i*25+17],uniform_LightSource[i*25+18],uniform_LightSource[i*25+19]);					light.linearAttenuation = uniform_LightSource[i*25+20];					light.specular = vec3( uniform_LightSource[i*25+21],uniform_LightSource[i*25+22],uniform_LightSource[i*25+23]);					light.quadraticAttenuation = uniform_LightSource[i*25+24];                     ambientColor *= vec4( frontMaterial.ambient.xyz * light.ambient , frontMaterial.ambient.w );                     diffuse = vec4( frontMaterial.diffuse.xyz * light.diffuse , frontMaterial.diffuse.w );                                        if( light.lightType == 0 ){						                        lightDir = normalize( light.spotDirection );						halfV = normalize(lightDir + varying_eyedir);						lightDir = normalize( lightDir * TBN );						NdotL = max(dot(lightDir,normal.xyz),0.0);                        lightColor.xyz = NdotL * diffuse.xyz ;						specularfract = max( dot(halfV,normal) , 0.0 );						specularfract = pow(specularfract, frontMaterial.shininess );						specularColor.xyz = light.specular.xyz * frontMaterial.specular.xyz * specularfract  ;					}        }}",
	ShadowMapping_vertex:"﻿uniform mat4 uniform_shadowMatrix ;varying vec4 shadowPosition ;void main(void){    shadowPosition = uniform_shadowMatrix * (uniform_ModelMatrix * vec4(attribute_position,1.0)) ;}",
	Shadow_fragment:"﻿varying vec4 varying_globalpos ;varying vec2 varying_uv0        ;uniform sampler2D diffuseTex ;vec4 pack(float fDist){   vec4 bitSh = vec4( 256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);   vec4 bitMsk = vec4( 0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);   vec4 comp;   comp = fDist * bitSh;   comp = fract(comp);   comp -= comp.xxyz * bitMsk;   return vec4(comp.y, comp.z, comp.w, comp.x);}void main(void){	vec4 color = texture2D( diffuseTex , varying_uv0 );	if( 0.3 > color.w ){		 discard ;	}	vec3 glFragCoord  = (varying_globalpos.xyz / varying_globalpos.w) * 0.5 + 0.5;    vec4 diffuse = pack( glFragCoord.z );} ",
	Shadow_vertex_sksleton:"﻿attribute vec3 attribute_position ;attribute vec3 attribute_normal ;attribute vec3 attribute_tangent ;attribute vec4 attribute_color ;attribute vec2 attribute_uv0 ;attribute vec2 attribute_uv1 ;attribute vec4 attribute_boneIndex ;attribute vec4 attribute_boneWeight ;const int bonesNumber = 0;uniform vec4 uniform_PoseMatrix[bonesNumber];uniform mat4 uniform_ModelMatrix ;uniform mat4 uniform_ProjectionMatrix ;uniform mat4 uniform_normalMatrix ;uniform vec3 uniform_eyepos ;varying vec4 varying_pos        ;varying vec2 varying_uv0        ;varying vec3 varying_eyeNormal  ;varying vec4 varying_color  ;varying vec3 varying_eyedir  ;varying vec3 varying_tangent	;varying vec4 varying_pp	;mat4 buildMat4(int index){  vec4 quat = uniform_PoseMatrix[index * 2 + 0];  vec4 translation = uniform_PoseMatrix[index * 2 + 1];  float xx = quat.x * quat.x;  float xy = quat.x * quat.y;  float xz = quat.x * quat.z;  float xw = quat.x * quat.w;  float yy = quat.y * quat.y;  float yz = quat.y * quat.z;  float yw = quat.y * quat.w;  float zz = quat.z * quat.z;  float zw = quat.z * quat.w;   return mat4(	   1.0 - 2.0 * (yy + zz),		2.0 * (xy + zw),		2.0 * (xz - yw),		0,	   2.0 * (xy - zw),				1.0 - 2.0 * (xx + zz),	2.0 * (yz + xw),		0,	   2.0 * (xz + yw),				2.0 * (yz - xw),		1.0 - 2.0 * (xx + yy),	0,	   translation.x,				translation.y,			translation.z,			1   );}void main(void){   vec4 temp_p = vec4(0.0, 0.0, 0.0, 0.0) ;   vec4 temp_position = vec4(attribute_position, 1.0) ;   temp_p += buildMat4(int(attribute_boneIndex.x)) * temp_position * attribute_boneWeight.x;   temp_p += buildMat4(int(attribute_boneIndex.y)) * temp_position * attribute_boneWeight.y;   temp_p += buildMat4(int(attribute_boneIndex.z)) * temp_position * attribute_boneWeight.z;   temp_p += buildMat4(int(attribute_boneIndex.w)) * temp_position * attribute_boneWeight.w;   temp_p =  uniform_ModelMatrix * temp_p;   varying_eyedir = normalize( uniform_eyepos - temp_p.xyz ) ;   varying_pos =  temp_p ;   temp_p = uniform_ProjectionMatrix * temp_p ;   gl_Position = temp_p ;   varying_pp = temp_p ;   varying_pos.w = -temp_p.z / 128.0 + 0.5 ;   varying_eyeNormal =  (uniform_normalMatrix*vec4(attribute_normal,0.0) ).xyz ;   varying_uv0 = attribute_uv0;   varying_color = vec4(attribute_tangent,1.0) ;      varying_tangent = normalize((uniform_ModelMatrix * vec4( attribute_tangent,0.0 )).xyz) ; }",
	Shadow_vertex_static:"﻿void main(void){}",
	SkyLightShader:"uniform vec4 uniform_skyLightSource ;vec3 skyLight(){    vec3 frontColor = vec3(1.0,1.0,1.0);    vec3 backColor = vec3(1.0,1.0,1.0);	vec3 dirlightDir = vec3( 0.0,1.0,0.0);    float s =  max(0.0 , dot( normalize(varying_normal) , dirlightDir) ) ;    frontColor = uniform_skyLightSource.xyz * (s * 0.5 + 0.5 )  * uniform_skyLightSource.w ;    return frontColor ;}void main(){    lightColor.xyz = skyLight() ;}",
	Tonemaping:"﻿varying vec2 uv ;uniform sampler2D texture2D_1;uniform sampler2D texture2D_2;void main(void){	vec4 lumfact = vec4(0.27,0.67,0.06,0.0);	float AveLum = 15.0;	float Key= 0.75 ;	vec4 color = texture2D(texture2D_1,uv);    float lum = dot(color , lumfact);    color *= Key *lum/AveLum;    color /= vec4(vec4(1.0,1.0,1.0,0.0)+color);    gl_FragColor = clamp(color + texture2D(texture2D_2,uv)*1.3, 0.0,1.0);}",
	back:"struct MaterialSource{    vec4 ambient;    vec4 diffuse;    vec4 specular;    vec4 emission;};struct LightModelSource{    vec4 ambient;};struct LightSource{    int lightType;    vec3 position;    float spotExponent;    vec3 spotDirection;    float spotCutoff;     vec3 halfVector;    float spotCosCutoff;     vec3 ambient;    float constantAttenuation;    vec3 diffuse;    float linearAttenuation;    vec3 specular;    float quadraticAttenuation;};varying vec4 varying_pos        ;varying vec3 varying_normal     ;varying vec2 varying_uv0        ;varying vec3 varying_eyeNormal  ;varying vec4 varying_color      ;uniform vec4 uniform_materialSource[4];uniform vec4 uniform_lightModelSource ;uniform float uniform_LightSource[25];void main() {        vec3 normal, lightDir;        vec4 diffuse, ambient, globalAmbient , finalColor ;        float NdotL;        finalColor = vec4(0.0,0.0,0.0,0.0);        normal = normalize(varying_eyeNormal);        MaterialSource frontMaterial = MaterialSource( materialSource[0] , materialSource[1] , materialSource[2] , materialSource[3] ) ;        LightModelSource lightModel = LightModelSource( uniform_lightModelSource );        for(int i = 0 ; i < 1 ; i++){                     LightSource light = LightSource(                         int(uniform_LightSource[i]),                         vec3(uniform_LightSource[i+1],uniform_LightSource[i+2],uniform_LightSource[i+3]),                          uniform_LightSource[i+4],                          vec3( uniform_LightSource[i+5],uniform_LightSource[i+6],uniform_LightSource[i+7]),                          uniform_LightSource[i+8],                          vec3( uniform_LightSource[i+9],uniform_LightSource[i+10],uniform_LightSource[i+11]),                          uniform_LightSource[i+12],                          vec3( uniform_LightSource[i+13],uniform_LightSource[i+14],uniform_LightSource[i+15]),                          uniform_LightSource[i+16],                          vec3( uniform_LightSource[i+17],uniform_LightSource[i+18],uniform_LightSource[i+19]),                          uniform_LightSource[i+20],                          vec3( uniform_LightSource[i+21],uniform_LightSource[i+22],uniform_LightSource[i+23]),                          uniform_LightSource[i+24]                     );                     if( light.lightType == 0 ){                         normal = normalize(varying_eyeNormal);                         lightDir = normalize(light.position);                         NdotL = max(dot(normal, lightDir), 0.0);                         diffuse = vec4( frontMaterial.diffuse.xyz * light.diffuse , frontMaterial.diffuse.w );                                                  ambient = vec4( frontMaterial.ambient.xyz * light.ambient , frontMaterial.ambient.w );                         globalAmbient = frontMaterial.ambient * lightModel.ambient ;                         finalColor +=  NdotL * diffuse + globalAmbient + ambient;                     }                 }        gl_FragColor =  finalColor ;}                                 color += att * (diffuse.xyz * NdotL + ambient.xyz);                                                               halfV = normalize(halfVector);                                                               NdotHV = max(dot(n,halfV),0.0);                                                               color += att * frontMaterial.specular.xyz * light.specular.xyz *                                                                               pow(NdotHV,frontMaterial.shininess);",
	default_vertex:"﻿attribute highp vec3 attribute_position ;attribute vec3 attribute_normal ;attribute vec3 attribute_tangent ;attribute vec4 attribute_color ;attribute vec2 attribute_uv0 ;attribute vec2 attribute_uv1 ;uniform mat4 uniform_ModelMatrix ;uniform mat4 uniform_ProjectionMatrix ;uniform mat4 uniform_normalMatrix ;uniform vec3 uniform_eyepos ;varying vec4 varying_pos        ;varying vec4 varying_globalpos        ;varying highp vec2 varying_uv0        ;varying vec2 varying_uv1        ;varying vec3 varying_eyeNormal  ;varying vec4 varying_color  ;varying vec3 varying_eyedir  ;varying vec3 varying_tangent	;void main(void){   highp vec4 temp_p ;   temp_p =  uniform_ModelMatrix * vec4(attribute_position,1.0) ;   varying_eyedir = uniform_eyepos ;   varying_pos =  temp_p ;   temp_p = uniform_ProjectionMatrix * temp_p ;   varying_globalpos = temp_p ;       varying_eyeNormal =  (uniform_normalMatrix*vec4(attribute_normal,0.0) ).xyz ;   varying_uv0 = attribute_uv0;   varying_uv1 = attribute_uv1;   varying_color = attribute_color ;   varying_tangent = normalize((uniform_ModelMatrix * vec4( attribute_tangent,0.0 )).xyz) ; }",
	depthMethod_fragment:"varying vec4 varying_pos        ;void main() {	gl_FragColor =  vec4( varying_pos.xyz/varying_pos.w , 1.0 ); }",
	diffuseMap_fragment:"﻿uniform sampler2D diffuseTex ;void main(void){    diffuse = texture2D( diffuseTex , varying_uv0 );	if( materialSource.cutAlpha > diffuse.w ){		 discard ;	}}",
	diffuseMethod_fragment:"mat3 TBN ;struct MaterialSource{    vec3 diffuse;    vec3 ambient;    vec3 specular;    float alpha;    float cutAlpha;    float shininess;	float diffusePower;	float specularPower;	float ambientPower;	float normalPower;};varying vec4 varying_pos        ;varying highp vec2 varying_uv0  ;varying vec2 varying_uv1        ;varying vec3 varying_eyeNormal  ;varying vec4 varying_color		;varying vec3 varying_eyedir		;varying vec3 varying_tangent	;uniform float uniform_materialSource[16];vec4 shadow  ;vec4 diffuse  ;vec3 light    ;vec4 specular ;vec3 normal  ;vec3 eyedir  ;vec4 ttt  ;void main() {	shadow = vec4(1.0,1.0,1.0,1.0);	ttt = vec4(1.0,1.0,1.0,0.0);	diffuse = vec4(1.0,1.0,1.0,1.0);	light   = vec3(0.0,0.0,0.0);	normal = varying_eyeNormal ;	MaterialSource materialSource;	materialSource.diffuse.x = uniform_materialSource[0];	materialSource.diffuse.y = uniform_materialSource[1];	materialSource.diffuse.z = uniform_materialSource[2];	materialSource.ambient.x = uniform_materialSource[3];	materialSource.ambient.y = uniform_materialSource[4];	materialSource.ambient.z = uniform_materialSource[5];	materialSource.specular.x = uniform_materialSource[6];	materialSource.specular.y = uniform_materialSource[7];	materialSource.specular.z = uniform_materialSource[8];	materialSource.alpha = uniform_materialSource[9];	materialSource.cutAlpha = uniform_materialSource[10];	materialSource.shininess = uniform_materialSource[11];	materialSource.diffusePower = uniform_materialSource[12];	materialSource.specularPower = uniform_materialSource[13];	materialSource.ambientPower = uniform_materialSource[14];	materialSource.normalPower = uniform_materialSource[15];	specular = vec4(materialSource.specular,0.0);	TBN[0] = varying_tangent ;	TBN[2] = normalize( normal.xyz ) ;    TBN[1] = normalize( cross(TBN[0],TBN[2]) ); 	eyedir = varying_eyedir.xyz - varying_pos.xyz ; }",
	diffuse_fragment:"﻿varying vec4 varying_pos        ;varying vec2 varying_uv0        ;varying vec3 varying_eyeNormal  ;varying vec4 varying_color  ;varying vec3 varying_eyedir  ;varying mat3 TBN ;uniform vec4 uniform_materialSource[4] ;vec4 ambientColor  ;vec4 diffuseColor  ;vec4 specularColor ;vec4 lightColor  ;vec3 normalTexC ;uniform sampler2D diffuseTexture ;void main(void){	 ambientColor= vec4( 1.0,1.1,0.1,1.0);	 lightColor = vec4( 1.0,1.0,1.0,1.0);	 specularColor = vec4( 1.0,1.0,1.0,1.0);	 normalTexC = vec3( 1.0,1.0,1.0);	 vec3 normal = normalize(varying_eyeNormal);     diffuseColor = texture2D( diffuseTexture , varying_uv0 );	 gl_FragColor = diffuseColor * lightColor ;}",
	diffuse_fragmentEnd:"void main() {	ttt.xyz = materialSource.ambient.xyz * materialSource.ambientPower;	light.xyz = light.xyz + ttt.xyz;	specular.xyz = specular.w * (specular.xyz * materialSource.specular * materialSource.specularPower);	diffuse.w = varying_color.w * materialSource.alpha * diffuse.w ;	diffuse.xyz = diffuse.xyz * materialSource.diffusePower ;		diffuse.xyz = ( (light.xyz+specular.xyz) * shadow.xyz + ttt.xyz ) * diffuse.xyz  ;	diffuse.xyz = diffuse.xyz / diffuse.w;}",
	directLight:"uniform vec4 uniform_directLightSource[7] ;const int max_directLight = 4 ;struct DirectLight{    vec3 dir;    vec3 diffuseColor;    float intensity;};void main() {    for( int i = 0 ; i < max_directLight ; i++ ) {            			DirectLight l;			l.dir = uniform_directLightSource[i*2].xyz;			l.diffuseColor = uniform_directLightSource[i*2+1].xyz;			l.intensity = uniform_directLightSource[i*2+1].w;            vec3 N = normalize(varying_normal);            vec3 L = l.dir ;            float lambertTerm = max(0.0,dot(N,L)) ;                        lightColor.xyz += lambertTerm * l.intensity ;    }}",
	directLight_fragment:"const int max_directLight = 1 ;uniform float uniform_directLightSource[7*max_directLight] ;struct DirectLight{    vec3 direction;	vec3 diffuse;    float intensity;};void calculateDirectLight( MaterialSource materialSource ){	float specularfract ;	vec3 halfV,ldir;	for(int i = 0 ; i < max_directLight ; i++){          DirectLight l = DirectLight(  			vec3(uniform_directLightSource[i*7+0],uniform_directLightSource[i*7+1],uniform_directLightSource[i*7+2]),			vec3(uniform_directLightSource[i*7+3],uniform_directLightSource[i*7+4],uniform_directLightSource[i*7+5]),			uniform_directLightSource[i*7+6]		  );		  vec3 N = normalize(normal) ;		  ldir = normalize(l.direction) ;		  float lambertTerm = min(1.0,max(0.0,dot(N,ldir))) ;		  		  		  light.xyz += (l.diffuse * lambertTerm*0.5 + l.diffuse*0.5) * l.intensity  ;		  if(lambertTerm>0.0){		     halfV = normalize(ldir + normalize(eyedir));		     specularfract = max( dot(halfV, N ) , 0.0 );		     specularfract = pow(specularfract, materialSource.shininess );		     specular.w += specularfract ;		  }	};}void main() {	calculateDirectLight( materialSource );}",
	distanceFog_fragment:"﻿struct Fog{   vec3 fogColor  ;   float globalDensity ;   vec2 startDistance ;   vec2 height ;};uniform float uniform_globalFog[8];void main(void){							Fog fog;	fog.fogColor = vec3(uniform_globalFog[0],uniform_globalFog[1],uniform_globalFog[2]);	fog.globalDensity = uniform_globalFog[3];	fog.startDistance = vec2(uniform_globalFog[4], uniform_globalFog[5]);	fog.height = vec2(uniform_globalFog[6], uniform_globalFog[7]) ;	float d = distance(varying_eyedir.xyz,varying_pos.xyz);	float distFog = max( 0.0 , d - fog.startDistance.x )* fog.startDistance.y;	float fogFactor = (1.0-exp(-fog.globalDensity * distFog )) ;	diffuse.xyz = mix( diffuse.xyz  , fog.fogColor , min(fogFactor,1.0) );} ",
	globalFogMethod_fragment:"﻿",
	lightMap_fragment:"﻿uniform sampler2D lightMapTex ;void main(void){    diffuse.xyz *= texture2D( lightMapTex , varying_uv1 ).xyz * 2.0 ;}",
	normalMap_fragment:"﻿uniform sampler2D normalTex;void main(void){     normal = normalize( TBN * ( normalize(  (2.0 * ( texture2D( normalTex , varying_uv0 ).xyz - vec3( 0.5 , 0.5 , 0.5 ) )) ) ) ) ;	 }",
	normalMethod_fragment:"mat3 TBN ;varying vec4 varying_pos        ;varying vec2 varying_uv0        ;varying vec3 varying_eyeNormal  ;varying vec3 varying_tangent	;vec4 test  ;vec4 diffuse  ;vec3 light    ;vec3 specular ;vec3 normal  ;void main() {	TBN[0] = varying_tangent ;	TBN[2] = normalize( varying_eyeNormal.xyz ) ;    TBN[1] = normalize( cross(TBN[0],TBN[2]) ); 	normal = 0.5 * normalize(varying_eyeNormal.xyz) + vec3( 0.5 , 0.5 , 0.5 ) ;	 	gl_FragColor =  vec4( normal , 1.0 ); }",
	particle_acceleRotate:"﻿attribute vec3 attribute_acceleRotate ;void main(void){	localRot.xyz += realTime * realTime * attribute_acceleRotate.xyz * 0.5 ;}",
	particle_acceleScale:"﻿attribute vec3 attribute_acceleScale ;void main(void){	localPos.xyz *= (realTime / 1000.0 * realTime / 1000.0) * attribute_acceleScale.xyz * 0.5 ;}",
	particle_acceleration:"﻿attribute vec3 attribute_acceleration ;void main(void){	localPos.xyz += realTime * realTime * attribute_acceleration.xyz * 0.5 ;}",
	particle_billboard:"﻿attribute float attribute_billboardXYZ ;uniform mat4 uniform_cameraMatrix ;uniform vec3 uniform_cameraRotate ;void main(void){		mat4 billboardMatrix;		if ( attribute_billboardXYZ == 111.0 ){		billboardMatrix = mat4(				uniform_cameraMatrix[0],				uniform_cameraMatrix[1],				uniform_cameraMatrix[2],				vec4(0.0, 0.0,1.0, 1.0));	}	else {			billboardMatrix = mat4(			vec4(1.0, 0.0, 0.0, 0.0),			vec4(0.0, 1.0, 0.0, 0.0),			vec4(0.0, 0.0, 1.0, 0.0),			vec4(0.0, 0.0, 0.0, 1.0));			if ( mod(attribute_billboardXYZ, 10.0) == 1.0 ){			billboardMatrix *= mat4(				vec4(1.0, 0.0, 0.0, 0.0),				vec4(0.0, uniform_cameraMatrix[1].y, uniform_cameraMatrix[1].z, 0.0),				vec4(0.0, uniform_cameraMatrix[2].y, uniform_cameraMatrix[2].z, 0.0),				vec4(0.0, 0.0, 0.0, 1.0)				);		}			if ( mod(attribute_billboardXYZ / 10.0, 10.0) == 1.0 ){			billboardMatrix *= mat4(				vec4(uniform_cameraMatrix[0].x, 0.0, uniform_cameraMatrix[0].z, 0.0),				vec4(0.0, 1.0, 0.0, 0.0),				vec4(uniform_cameraMatrix[2].x, 0.0, uniform_cameraMatrix[2].z, 0.0),				vec4(0.0, 0.0, 0.0, 1.0)				);		}			if ( mod(attribute_billboardXYZ / 100.0, 10.0) == 1.0 ){			billboardMatrix *= mat4(				vec4(uniform_cameraMatrix[0].x, uniform_cameraMatrix[0].y, 0.0, 0.0),				vec4(uniform_cameraMatrix[1].x, uniform_cameraMatrix[1].y, 0.0, 0.0),				vec4(0.0, 0.0, 1.0, 0.0),				vec4(0.0, 0.0, 0.0, 1.0)				);		}		}		}",
	particle_color:"﻿attribute vec4 attribute_startColor ;attribute vec4 attribute_endColor ;void main(void){}",
	particle_lifeRotate:"﻿attribute vec3 attribute_lifeRotate ;void main(void){	localRot.xyz += realTime * attribute_lifeRotate.xyz;}",
	particle_offset:"﻿",
	particle_position:"﻿",
	particle_scale:"﻿attribute vec3 attribute_scale ;void main(void){	localScal.xyz += (attribute_scale.y - attribute_scale.x) * ratioTime + attribute_scale.x;}",
	particle_speed:"﻿attribute vec3 attribute_speed ;void main(void){	localPos.xyz += realTime * attribute_speed.xyz ;}",
	particle_time:"﻿attribute vec4 attribute_time ;void main(void){	float startTime = attribute_time.x + attribute_time.y * attribute_position.w ;	realTime = startTime + attribute_time.z ; 	if ( mod(attribute_time.w, 10.0) == 1.0 ){		realTime = mod( uniform_time , realTime );		ratioTime = realTime / attribute_time.z;	}	else{		realTime = uniform_time;		if( realTime > attribute_time.z ){			ratioTime = 0.0 ;			localScal.xyz = localScal.xyz * ratioTime ; 		}else{			ratioTime = realTime / attribute_time.z;		}	}	realTime = realTime - startTime ;	if( realTime < 0.0 ){		varying_color.w = 0.0 ; 		realTime = 0.0 ; 		localPos = vec3(0.0,0.0,0.0);	}}",
	particle_uv:"﻿attribute vec2 attribute_uv0 ;void main(void){}",
	particle_vertex:"﻿attribute vec4 attribute_position ;attribute vec3 attribute_offset ;attribute highp vec2 attribute_uv0 ;varying vec4 varying_pos        ;varying highp vec2 varying_uv0        ;varying vec2 varying_uv1        ;varying vec3 varying_eyeNormal  ;varying vec4 varying_color  ;varying vec3 varying_eyedir  ;varying vec3 varying_tangent	;uniform mat4 uniform_ModelMatrix ;uniform mat4 uniform_ProjectionMatrix ;uniform mat4 uniform_normalMatrix ;uniform vec3 uniform_eyepos ;uniform float uniform_time ;uniform mat4 uniform_testMatrix ;vec3 localPos  ;vec3 localRot  ;vec3 localScal  ; vec4 color ;highp float realTime ;highp float ratioTime ;const float pi = 3.1415926 ;const float t = 16.666 ;mat4 buildRotMat4(vec3 rot){    mat4 ret = mat4(	vec4(1.0, 0.0, 0.0, 0.0),	vec4(0.0, 1.0, 0.0, 0.0),	vec4(0.0, 0.0, 1.0, 0.0),	vec4(0.0, 0.0, 0.0, 1.0)	);	float s;	float c;	s = sin(rot.x);	c = cos(rot.x);		ret *= mat4(	vec4(1.0, 0.0, 0.0, 0.0),	vec4(0.0, c, s, 0.0),	vec4(0.0, -s, c, 0.0),	vec4(0.0, 0.0, 0.0, 1.0)	);		s = sin(rot.y);	c = cos(rot.y);		ret *= mat4(	vec4(c, 0.0, -s, 0.0),	vec4(0.0, 1.0, 0.0, 0.0),	vec4(s, 0.0, c, 0.0),	vec4(0.0, 0.0, 0.0, 1.0)	);	s = sin(rot.z);	c = cos(rot.z);	ret *= mat4(	vec4(c, s, 0.0, 0.0),	vec4(-s, c, 0.0, 0.0),	vec4(0.0, 0.0, 1.0, 0.0),	vec4(0.0, 0.0, 0.0, 1.0)	);	return ret;}void main(void){	localScal = vec3(1.0,1.0,1.0) ; 	localPos = vec3(0.0,0.0,0.0) ; 	localRot = vec3(0.0,0.0,0.0) ; 	varying_color = vec4(1.0,1.0,1.0,1.0);	varying_uv0 = attribute_uv0 ;}",
	particle_vertexEnd:"﻿void main(void){	vec4 temp_p = uniform_ProjectionMatrix * uniform_ModelMatrix * ( (billboardMatrix * (buildRotMat4(localRot) * vec4(attribute_position.xyz * localScal,1.0))) + vec4(attribute_offset.xyz+localPos.xyz,1.0));	}",
	pointLight_fragment:"const int max_pointLight = 0 ;uniform float uniform_pointLightSource[7*max_pointLight] ;struct PointLight{        vec3 lightPos ;        vec3 color ;        float intensity;};void calculatePointLight(MaterialSource materialSource){	vec3 ldir,halfV;    float NdotL,dist,lambertTerm,specularfract;	for(int i = 0 ; i < max_pointLight ; i++){        										PointLight L;		L.lightPos = vec3(uniform_pointLightSource[i*7],uniform_pointLightSource[i*7+1],uniform_pointLightSource[i*7+2]);		L.color = vec3(uniform_pointLightSource[i*7+3],uniform_pointLightSource[i*7+4],uniform_pointLightSource[i*7+5]);		L.intensity = uniform_pointLightSource[i*7+6];		  ldir = L.lightPos - varying_pos.xyz ;		  dist = length(ldir);		  ldir = normalize(ldir );		  NdotL = max(dot(normalize(normal),ldir),0.0);		  		  lambertTerm = ( L.intensity  ) / ( dist * dist )  ;		  light.xyz += lambertTerm * (NdotL * L.color.xyz) * 1000.0 ;		  halfV = normalize(ldir - eyedir);		  specularfract = max( dot(halfV,normal) , 0.0 );		  specularfract = pow(specularfract, materialSource.shininess );		  specular.xyz += materialSource.specular.xyz * specularfract * lambertTerm ;	};}void main() {   calculatePointLight(materialSource);}",
	postCanvas_fragment:"﻿varying vec2 uv ;uniform sampler2D texture2D_1 ;void main(void){   gl_FragColor = texture2D( texture2D_1 , uv ); }",
	postCanvas_vertex:"﻿attribute vec3 attribute_position ;attribute vec2 attribute_uv0 ;uniform mat4 uniform_ProjectionMatrix ;varying vec2 uv ;void main(void){   uv = attribute_uv0 ;   gl_Position = uniform_ProjectionMatrix * vec4(attribute_position,1.0) ;}",
	shadowmapping_fragment:"﻿varying vec4 shadowPosition ;uniform sampler2D shadowMapTex ;uniform vec4 shadowParameter  ;float unpack(sampler2D ShadowMapS, vec2 texcood){   vec4 vec = texture2D(ShadowMapS, texcood);   vec4 bitShifts = vec4(1.0/(256.0*256.0), 1.0/256.0, 1.0, 1.0/(256.0*256.0*256.0));   return dot(vec,bitShifts)  ;}void main(void){	vec3 shadowMapPosition = shadowPosition.xyz / shadowPosition.w;      shadowMapPosition = shadowMapPosition.xyz * 0.5 + 0.5 ;  	float depth = unpack(shadowMapTex,shadowMapPosition.xy);			if( depth < (shadowMapPosition.z - shadowParameter.w ) )		shadow.xyz = shadowParameter.xyz ; }",
	skeleton_vertex:"﻿attribute vec3 attribute_position ;attribute vec3 attribute_normal ;attribute vec3 attribute_tangent ;attribute vec4 attribute_color ;attribute vec2 attribute_uv0 ;attribute vec2 attribute_uv1 ;attribute vec4 attribute_boneIndex ;attribute vec4 attribute_boneWeight ;const int bonesNumber = 0;uniform vec4 uniform_PoseMatrix[bonesNumber];uniform mat4 uniform_ModelMatrix ;uniform mat4 uniform_ProjectionMatrix ;uniform mat4 uniform_normalMatrix ;uniform vec3 uniform_eyepos ;varying vec4 varying_pos        ;varying vec2 varying_uv0        ;varying vec3 varying_eyeNormal  ;varying vec4 varying_color  ;varying vec3 varying_eyedir  ;varying vec3 varying_tangent	;mat4 buildMat4(int index){  vec4 quat = uniform_PoseMatrix[index * 2 + 0];  vec4 translation = uniform_PoseMatrix[index * 2 + 1];  float xx = quat.x * quat.x;  float xy = quat.x * quat.y;  float xz = quat.x * quat.z;  float xw = quat.x * quat.w;  float yy = quat.y * quat.y;  float yz = quat.y * quat.z;  float yw = quat.y * quat.w;  float zz = quat.z * quat.z;  float zw = quat.z * quat.w;   return mat4(	   1.0 - 2.0 * (yy + zz),		2.0 * (xy + zw),		2.0 * (xz - yw),		0,	   2.0 * (xy - zw),				1.0 - 2.0 * (xx + zz),	2.0 * (yz + xw),		0,	   2.0 * (xz + yw),				2.0 * (yz - xw),		1.0 - 2.0 * (xx + yy),	0,	   translation.x,				translation.y,			translation.z,			1   );}void main(void){   vec4 temp_p = vec4(0.0, 0.0, 0.0, 0.0) ;   vec4 temp_position = vec4(attribute_position, 1.0) ;   temp_p += buildMat4(int(attribute_boneIndex.x)) * temp_position * attribute_boneWeight.x;   temp_p += buildMat4(int(attribute_boneIndex.y)) * temp_position * attribute_boneWeight.y;   temp_p += buildMat4(int(attribute_boneIndex.z)) * temp_position * attribute_boneWeight.z;   temp_p += buildMat4(int(attribute_boneIndex.w)) * temp_position * attribute_boneWeight.w;   temp_p =  uniform_ModelMatrix * temp_p;   varying_eyedir = uniform_eyepos.xyz ;   varying_pos =  temp_p ;   temp_p = uniform_ProjectionMatrix * temp_p ;   gl_Position = temp_p ;   varying_pos.w = -temp_p.z / 128.0 + 0.5 ;   varying_eyeNormal =  (uniform_normalMatrix*vec4(attribute_normal,0.0) ).xyz ;   varying_uv0 = attribute_uv0;   varying_color = vec4(1.0,1.0,1.0,1.0) ;      varying_tangent = normalize((uniform_ModelMatrix * vec4( attribute_tangent,0.0 )).xyz) ; }",
	sky_fragment:"uniform samplerCube sky_texture ;varying vec3 varying_pos   ;void main(void){		vec4 ref = vec4(textureCube( sky_texture , varying_pos.xyz ));    gl_FragColor = ref ;}",
	sky_vertex:"﻿attribute vec3 attribute_position ;uniform mat4 uniform_ProjectionMatrix ;uniform mat4 uniform_ModelMatrix ;varying vec3 varying_pos        ;void main(void){   varying_pos =  attribute_position ;   gl_Position = uniform_ProjectionMatrix * uniform_ModelMatrix * vec4(varying_pos,1.0) ;}",
	specularMap_fragment:"﻿uniform sampler2D specularTex;void main(void){    specular.xyz = texture2D( specularTex , varying_uv0 ).xyz ;}",
	spheresky_fragment:"uniform sampler2D sky_texture ;varying vec2 uv        ;varying vec3 normal        ;void main(void){    vec4 color = texture2D( sky_texture , uv );    gl_FragColor = color  ;}",
	spheresky_vertex:"﻿attribute vec3 attribute_position ;attribute vec3 attribute_normal ;attribute vec2 attribute_uv0 ;uniform mat4 uniform_ProjectionMatrix ;uniform mat4 uniform_ModelMatrix ;uniform mat4 uniform_normalMatrix ;varying vec3 normal        ;varying vec2 uv        ;void main(void){    vec4 vVert4 = uniform_ModelMatrix * vec4(attribute_position,1.0) ;    gl_Position = uniform_ProjectionMatrix * vVert4 ;	    vec3 vEyeNormal =  normalize(attribute_position);            float pi = 3.1415926 ;        uv.x = vEyeNormal.x / pi + 0.5 ;    uv.y = vEyeNormal.y / pi + 0.5 ;	uv = attribute_uv0 ;}",
	sportLight_fragment:"const int max_sportLight = 1 ;uniform float uniform_sportLightSource[14*max_sportLight] ;struct SpotLight{       vec3 lightPos ;       vec3 spotDirection ;       vec3 spotColor ;       float spotExponent ;       float spotCosCutoff ;       float constantAttenuation ;       float linearAttenuation ;       float quadrAttenuation ;};void calculateSpotLight( MaterialSource materialSource ){	vec3 ldir,halfV;	float NdotL,dist,att,spotEffect,specularfract;	for(int i = 0 ; i < max_sportLight ; i++){																																	SpotLight L;			L.lightPos = vec3(uniform_sportLightSource[i*max_sportLight],uniform_sportLightSource[i*max_sportLight+1],uniform_sportLightSource[i*max_sportLight+2]);			L.spotDirection = vec3(uniform_sportLightSource[i*max_sportLight+3],uniform_sportLightSource[i*max_sportLight+4],uniform_sportLightSource[i*max_sportLight+5]);			L.spotColor = vec3(uniform_sportLightSource[i*max_sportLight+6],uniform_sportLightSource[i*max_sportLight+7],uniform_sportLightSource[i*max_sportLight+8]);			L.spotExponent = uniform_sportLightSource[i*max_sportLight+9];			L.spotCosCutoff = uniform_sportLightSource[i*max_sportLight+10];			L.constantAttenuation = uniform_sportLightSource[i*max_sportLight+11];			L.linearAttenuation = uniform_sportLightSource[i*max_sportLight+12];			L.quadrAttenuation = uniform_sportLightSource[i*max_sportLight+13];		   		     ldir = normalize( L.lightPos.xyz - varying_pos.xyz );		     NdotL = max(dot(normal,ldir),0.0);			 dist = length(ldir);		     spotEffect = dot(normalize(L.spotDirection), normalize(ldir));		    if (spotEffect > L.spotCosCutoff )		    {		        spotEffect = pow(spotEffect, L.spotExponent);		        att = spotEffect / (L.constantAttenuation + L.linearAttenuation * dist + L.quadrAttenuation * dist * dist) ;				light.xyz += att * L.spotColor.xyz * NdotL ;		    }		  halfV = normalize(ldir - eyedir);		  specularfract = max( dot(halfV,normal) , 0.0 );		  specularfract = pow(specularfract, materialSource.shininess );		  specular.w += specularfract ;	};}void main() {	calculateSpotLight( materialSource );}",
	terrainRGBA_fragment:"uniform sampler2D maskTex ;uniform sampler2D splat_0Tex ;uniform sampler2D splat_1Tex ;uniform sampler2D splat_2Tex ;uniform sampler2D splat_3Tex ;uniform sampler2D lightMapTex ;uniform float uvs[8];void main() {	vec4 splat_control = texture2D ( maskTex , varying_uv0 );	vec4 cc = vec4(0.0,0.0,0.0,1.0);	vec2 uv = varying_uv0 ;	eyedir = varying_eyedir.xyz - varying_pos.xyz ; 	cc.xyz = splat_control.x * texture2D (splat_0Tex, uv * vec2(uvs[0],uvs[1])).xyz ;	cc.xyz += splat_control.y * texture2D (splat_1Tex, varying_pos.xy /400.0 ).xyz;	cc.xyz += splat_control.z * vec4(texture2D (splat_2Tex, uv* vec2(uvs[4],uvs[5]))).xyz;	cc.xyz += (1.0-length(splat_control.xyz)) * vec4(texture2D (splat_3Tex, uv* vec2(uvs[6],uvs[7]))).xyz;	diffuse.xyz = cc.xyz * diffuse.xyz ;	diffuse.xyz = diffuse.xyz * (texture2D( lightMapTex , varying_uv1 ).xyz ) ;}",
	warpedImage_fragment:"﻿varying vec2 uv;uniform sampler2D texture2D_1;uniform	vec3 _K ;void main(){		float _K1 = _K.x ;			vec2 _texScale = vec2(_K.yz) ;			vec2 screenCenter = vec2(0.5,0.5);		float norm = length(screenCenter);				vec2 radial_vector = (uv - screenCenter)/norm;		float radial_vector_len = length(radial_vector);		vec2 radial_vector_unit = radial_vector.xy / radial_vector_len;			float new_dist = radial_vector_len + _K1 * pow(radial_vector_len,3.0);		vec2 warp_coord = radial_vector_unit * (new_dist * norm);		warp_coord = warp_coord * _texScale;		warp_coord = warp_coord + screenCenter;			vec4 newColor = vec4(0.0,0.0,0.0,1.0);		if ( (warp_coord.x > 1.0  || warp_coord.x < 0.0) || (warp_coord.y > 1.0 || warp_coord.y < 0.0) ){			newColor = vec4(0.0,0.0,0.0,1.0);					}else{			newColor = texture2D (texture2D_1, vec2(warp_coord.x,warp_coord.y) );		}		gl_FragColor = newColor;	}",
	wireframe_fragment:"﻿varying vec4 varying_color ;void main(void){   gl_FragColor = varying_color; }",
	wireframe_vertex:"﻿attribute vec3 attribute_position ;varying vec4 varying_color ;uniform mat4 uniform_ModelMatrix ;uniform mat4 uniform_ProjectionMatrix ;uniform vec4 uniform_color ;uniform float uniform_pointSize = 1.0 ;void main(void){	varying_color = uniform_color;	gl_PointSize = uniform_pointSize;	gl_Position = uniform_ProjectionMatrix * uniform_ModelMatrix * vec4(attribute_position,1.0) ;}",

}
}